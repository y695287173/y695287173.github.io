[{"title":"清除浮动的几种方法","date":"2017-02-27T14:42:39.000Z","path":"2017/02/27/float-clear/","text":"在CSS布局中，浮动是一个常用的属性，但在子元素设置float属性时height超过父元素，在父元素未设置高度或高度小于子元素时，会出现子元素溢出父元素，从而使父元素高度出现塌陷的情况。而为了防止子元素溢出到父元素包围以外的css处理，就被称为清除浮动 此处引用W3C中清除浮动的例子：http://www.w3school.com.cn/css/css_positioning_floating.asp.news { background-color: gray; border: solid 1px black; } .news img { float: left; } .news p { float: right; } &lt;div class=&quot;news&quot;&gt; &lt;img src=&quot;news-pic.jpg&quot; /&gt; &lt;p&gt;some text&lt;/p&gt; &lt;/div&gt; 主要几种常用清除浮动的方法：方法1：使用css的:after伪元素进行清除浮动.news { background-color: gray; border: solid 1px black; } .news img { float: left; } .news p { float: right; } .clearfix:after{ content: &quot;&quot;; display: block; height: 0; clear: both; visibility: hidden; } .clearfix { /* 触发 hasLayout */ zoom: 1; } &lt;div class=&quot;news clearfix&quot;&gt; &lt;img src=&quot;news-pic.jpg&quot; /&gt; &lt;p&gt;some text&lt;/p&gt; &lt;/div&gt; 此方法的原理为在要清除浮动的父元素最后添加一个带有clear：both属性，且不可见的元素，以此元素来清除浮动。与直接宰父元素最后添加一个带有clear：both的元素原理一直，但是使用：after属性不会因为添加一个无意义的元素而破坏html文档的结构。而zoom：1，是为了触发IE的hasLayout来清除浮动。 方法2：使用CSS的overflow属性overflow:auto; 或 overflow：hidden； 另外同理需要加上zoom：1的IE HACK来兼容IE .news { background-color: gray; border: solid 1px black; overflow: auto; *zoom: 1; } .news img { float: left; } .news p { float: right; } &lt;div class=&quot;news&quot;&gt; &lt;img src=&quot;news-pic.jpg&quot; /&gt; &lt;p&gt;some text&lt;/p&gt; &lt;/div&gt; 此处需要解释一下，这种清除浮动的方式是和上面第一种方式有着不同的原理。第一种方式是利用了父元素内最后一个元素或伪元素具有的clear属性来进行清除浮动的，而此方法是触发了BFC来清除浮动的。即Block formatting contexts （块级格式化上下文），简称 BFC。 BFC 是页面中独立的一个容器，容器内的子元素不会对外部产生影响。 BFC具有如下特性： BFC会阻止内部子元素在垂直方向的外边距重叠（margin），但BFC之间和同一个BFC内的外边距重叠问题仍然存在。 BFC可以包裹住浮动元素 BFC不会重叠浮动元素 因此利用BFC可以包裹浮动元素的特性来清除浮动 方法3：浮动元素的外部元素也设置为浮动元素这种方法因为会影响布局，所以一般也使用不上。主要还是推荐上述两种方法。 具体想深入了解清除浮动的方法和其中的原理，可以参考如下链接： 那些年我们一起清除过的浮动：http://www.iyunlu.com/view/css-xhtml/55.html","tags":[{"name":"css","slug":"css","permalink":"https://y695287173.github.io/tags/css/"}]},{"title":"font 属性简写","date":"2017-02-15T16:06:07.000Z","path":"2017/02/16/font-order/","text":"css 中font的属性可以通过合并成为一个font属性，这样写起来方便，也简化了代码。 font属性 font-family（字体族）: “Arial”、“Times New Roman”、“宋体”、“黑体”等;font-style（字体样式）: normal（正常）、italic（斜体）或oblique（倾斜）;font-variant (字体变化): normal（正常）或small-caps（小体大写字母）;font-weight (字体浓淡): 是normal（正常）或bold（加粗）。有些浏览器甚至支持采用100到900之间的数字（以百为单位）;font-size（字体大小）: 可通过多种不同单位（比如像素或百分比等）来设置, 如：12xp，12pt，120%，1em 简写顺序如下： 顺序：font-style | font-variant | font-weight | font-size | line-height | font-family 举例12345678.font&#123; font-style:italic; font-variant:small-caps; font-weight:bold; font-size:12px; line-height:1.5em; font-family:arial,verdana;&#125; 简写后：1.font&#123;font:italic small-caps bold 12px/1.5em arial,verdana;&#125; 注意 简写时，font-size和line-height只能通过斜杠/组成一个值，不能分开写。 顺序不能改变.这种简写方法只有在同时指定font-size和font-family属性时才起作用。而且，如果你没有设定font-weight, font-style, 以及 font-varient ，他们会使用缺省值","tags":[{"name":"css","slug":"css","permalink":"https://y695287173.github.io/tags/css/"}]},{"title":"《javaScript高级程序设计》第11章 DOM拓展总结","date":"2017-02-14T05:38:04.000Z","path":"2017/02/14/javascriptnote11/","text":"摘录总结自《javaScript高级程序设计》 对 DOM 的两个主要的扩展是 Selectors API（选择符 API）和 HTML5。这两个扩展都源自开发社区，而将某些常见做法及 API 标准化一直是众望所归。此外，还有一个不那么引人瞩目的 Element Traversal（元素遍历）规范，为 DOM 添加了一些属性。虽然前述两个主要规范（特别是 HTML5）已经涵盖了大量的 DOM 扩展，但专有扩展依然存在。本章也会介绍专有的 DOM 扩展。 11.1 选择符 API众多 JavaScript 库中最常用的一项功能，就是根据 CSS 选择符选择与某个模式匹配的 DOM 元素。实际上，jQuery（www.jquery.com）的核心就是通过 CSS 选择符查询 DOM 文档取得元素的引用，从而抛开了 getElementById() 和 getElementsByTagName() 。 Selectors API Level 1的核心是两个方法： querySelector() 和 querySelectorAll() 。在兼容的浏览器中，可以通过 Document 及 Element 类型的实例调用它们。目前已完全支持 Selectors API Level 1的浏览器有 IE 8+、Firefox 3.5+、Safari 3.1+、Chrome和 Opera 10+。 11.1.1 querySelector() 方法querySelector() 方法接收一个 CSS 选择符，返回与该模式匹配的第一个元素，如果没有找到匹配的元素，返回 null 。请看下面的例子。 1234567891011//取得 body 元素var body = document.querySelector(\"body\");//取得 ID 为\"myDiv\"的元素var myDiv = document.querySelector(\"#myDiv\");//取得类为\"selected\"的第一个元素var selected = document.querySelector(\".selected\");//取得类为\"button\"的第一个图像元素var img = document.body.querySelector(\"img.button\"); 如果传入了不被支持的选择符， querySelector()会抛出错误。 11.1.1 querySelectorAll() 方法与querySelector()基本相同，差异为返回全部元素，如下例子： 123456789101112131415//取得某&lt;div&gt;中的所有&lt;em&gt;元素（类似于 getElementsByTagName(\"em\")）var ems = document.getElementById(\"myDiv\").querySelectorAll(\"em\");//取得类为\"selected\"的所有元素var selecteds = document.querySelectorAll(\".selected\");//取得所有&lt;p&gt;元素中的所有&lt;strong&gt;元素var strongs = document.querySelectorAll(\"p strong\");要取得返回的 NodeList 中的每一个元素，可以使用 item() 方法，也可以使用方括号语法，比如：var i, len, strong;for (i=0, len=strongs.length; i &lt; len; i++)&#123; strong = strongs[i]; //或者 strongs.item(i) strong.className = \"important\";&#125; 11.1.3 matchesSelector() 方法Selectors API Level 2 规范为 Element 类型新增了一个方法 matchesSelector() 。这个方法接收一个参数，即 CSS 选择符，如果调用元素与该选择符匹配，返回 true ；否则，返回 false 。看例子。 截至 2011 年年中，还没有浏览器支持 matchesSelector() 方法；不过，也有一些实验性的实现。IE 9+通过 msMatchesSelector() 支持该方法，Firefox 3.6+通过 mozMatchesSelector() 支持该方法，Safari 5+和 Chrome 通过 webkitMatchesSelector() 支持该方法。因此，如果你想使用这个方法，最好是编写一个包装函数。 12345678910111213141516function matchesSelector(element, selector)&#123; if (element.matchesSelector)&#123; return element.matchesSelector(selector); &#125; else if (element.msMatchesSelector)&#123; return element.msMatchesSelector(selector); &#125; else if (element.mozMatchesSelector)&#123; return element.mozMatchesSelector(selector); &#125; else if (element.webkitMatchesSelector)&#123; return element.webkitMatchesSelector(selector); &#125; else &#123; throw new Error(\"Not supported.\"); &#125;&#125;if (matchesSelector(document.body, \"body.page1\"))&#123; //执行操作&#125; 11.2 元素遍历对于元素间的空格，IE9及之前版本不会返回文本节点，而其他所有浏览器都会返回文本节点。这样，就导致了在使用 childNodes 和 firstChild 等属性时的行为不一致。为了弥补这一差异，而同时又保持 DOM规范不变，Element Traversal规范（www.w3.org/TR/ElementTraversal/）新定义了一组属性。Element Traversal API 为 DOM 元素添加了以下 5 个属性。 childElementCount ：返回子元素（不包括文本节点和注释）的个数。firstElementChild ：指向第一个子元素； firstChild 的元素版。lastElementChild ：指向最后一个子元素； lastChild 的元素版。previousElementSibling ：指向前一个同辈元素； previousSibling 的元素版。nextElementSibling ：指向后一个同辈元素； nextSibling 的元素版。 如下： 1234567891011121314151617var i, len,child = element.firstChild;while(child != element.lastChild)&#123; if (child.nodeType == 1)&#123; //检查是不是元素 processChild(child); &#125; child = child.nextSibling;&#125;而使用 Element Traversal 新增的元素，代码会更简洁。var i, len,child = element.firstElementChild;while(child != element.lastElementChild)&#123; processChild(child); //已知其是元素 child = child.nextElementSibling;&#125; 支持 Element Traversal 规范的浏览器有 IE 9+、Firefox 3.5+、Safari 4+、Chrome 和 Opera 10+。 11.3 HTML5为了让开发人员适应并增加对 class 属性的新认识，HTML5 新增了很多 API，致力于简化 CSS 类的用法。 1. getElementsByClassName() 方法这个方法最早出现在 JavaScript 库中，是通过既有的 DOM 功能实现的，而原生的实现具有极大的性能优势。 12345/取得所有类中包含\"username\"和\"current\"的元素，类名的先后顺序无所谓var allCurrentUsernames = document.getElementsByClassName(\"username current\");//取得 ID 为\"myDiv\"的元素中带有类名\"selected\"的所有元素var selected = document.getElementById(\"myDiv\").getElementsByClassName(\"selected\"); 使用这个方法可以更方便地为带有某些类的元素添加事件处理程序，从而不必再局限于使用 ID或标签名。不过别忘了，因为返回的对象是 NodeList ，所以使用这个方法与使用 getElementsByTagName()以及其他返回 NodeList 的 DOM 方法都具有同样的性能问题。支持 getElementsByClassName() 方法的浏览器有 IE 9+、Firefox 3+、Safari 3.1+、Chrome 和Opera 9.5+。 2. classList 属性在HTML5之前，我们要改变元素的class属性时，需要做如下操作： 1&lt;div class=\"bd user disabled\"&gt;...&lt;/div&gt; 这个 元素一共有三个类名。要从中删除一个类名，需要把这三个类名拆开，删除不想要的那个，然后再把其他类名拼成一个新字符串。请看下面的例子。 123456789101112131415161718192021//删除\"user\"类//首先，取得类名字符串并拆分成数组var classNames = div.className.split(/\\s+/);//找到要删的类名var pos = -1, i, len;for (i=0, len=classNames.length; i &lt; len; i++)&#123; if (classNames[i] == \"user\")&#123; pos = i; break; &#125;&#125;//删除类名classNames.splice(i,1);//把剩下的类名拼成字符串并重新设置div.className = classNames.join(\" \"); HTML5 新增了一种操作类名的方式，可以让操作更简单也更安全，那就是为所有元素添加classList 属性。这个 classList 属性是新集合类型 DOMTokenList 的实例。 add(value) ：将给定的字符串值添加到列表中。如果值已经存在，就不添加了。contains(value) ：表示列表中是否存在给定的值，如果存在则返回 true ，否则返回 false 。remove(value) ：从列表中删除给定的字符串。toggle(value) ：如果列表中已经存在给定的值，删除它；如果列表中没有给定的值，添加它。 这样，前面那么多行代码用下面这一行代码就可以代替了： 1div.classList.remove(\"user\"); 以上代码能够确保其他类名不受此次修改的影响。其他方法也能极大地减少类似基本操作的复杂性，如下面的例子所示。 123456789101112131415161718//删除\"disabled\"类div.classList.remove(\"disabled\");//添加\"current\"类div.classList.add(\"current\");//切换\"user\"类div.classList.toggle(\"user\");//确定元素中是否包含既定的类名if (div.classList.contains(\"bd\") &amp;&amp; !div.classList.contains(\"disabled\"))&#123; //执行操作)//迭代类名for (var i=0, len=div.classList.length; i &lt; len; i++)&#123; doSomething(div.classList[i]);&#125; 有了 classList 属性，除非你需要全部删除所有类名，或者完全重写元素的 class 属性，否则也就用不到 className 属性了。 支持 classList 属性的浏览器有 Firefox 3.6+和 Chrome。 11.3.2 焦点管理HTML5 也添加了辅助管理 DOM 焦点的功能。首先就是 document.activeElement 属性，这个属性始终会引用 DOM 中当前获得了焦点的元素。元素获得焦点的方式有页面加载、用户输入（通常是通过按 Tab 键）和在代码中调用 focus() 方法。来看几个例子。 123var button = document.getElementById(\"myButton\");button.focus();alert(document.activeElement === button); //true 默认情况下，文档刚刚加载完成时， document.activeElement 中保存的是 document.body 元素的引用。文档加载期间， document.activeElement 的值为 null 。另外就是新增了 document.hasFocus() 方法，这个方法用于确定文档是否获得了焦点。 12button.focus();alert(document.hasFocus()); //true 实现了这两个属性的浏览器的包括 IE 4+、Firefox 3+、Safari 4+、Chrome 和 Opera 8+。 11.3.3 HTMLDocument 的变化HTML5 扩展了 HTMLDocument ，增加了新的功能。与 HTML5 中新增的其他DOM扩展类似，这些变化同样基于那些已经得到很多浏览器完美支持的专有扩展。所以，尽管这些扩展被写入标准的时间相对不长，但很多浏览器很早就已经支持这些功能了。 1. readyState 属性 loading ，正在加载文档；complete ，已经加载完文档。 在这个属性得到广泛支持之前，要实现这样一个指示器，必须借助 onload 事件处理程序设置一个标签，表明文档已经加载完毕。基本用法： 123if (document.readyState == \"complete\")&#123; //执行操作&#125; 支持 readyState 属性的浏览器有 IE4+、Firefox 3.6+、Safari、Chrome和 Opera 9+。 2. 兼容模式就像下面例子中所展示的那样，在标准模式下， document.compatMode 的值等于 “CSS1Compat” ，而在混杂模式下， document.compatMode 的值等于 “BackCompat” 。 12345if (document.compatMode == \"CSS1Compat\")&#123; alert(\"Standards mode\");&#125; else &#123; alert(\"Quirks mode\");&#125; 后来，陆续实现这个属性的浏览器有 Firefox、Safari 3.1+、Opera 和 Chrome。最终，HTML5 也把这个属性纳入标准，对其实现做出了明确规定。 3. head 属性作为对 document.body 引用文档的 元素的补充，HTML5 新增了 document.head 属性，引用文档的 head 元素。要引用文档的 元素，可以结合使用这个属性和另一种后备方法。 1var head = document.head || document.getElementsByTagName(\"head\")[0]; 如果可用，就使用 document.head ，否则仍然使用 getElementsByTagName() 方法。实现 document.head 属性的浏览器包括 Chrome 和 Safari 5。 11.3.4 字符集属性12alert(document.charset); //\"UTF-16\"document.charset = \"UTF-8\"; 如果文档没有使用默认的字符集，那 charset 和 defaultCharset 属性的值可能会不一样，例如： 123if (document.charset != document.defaultCharset)&#123; alert(\"Custom character set being used.\");&#125; 支持 document.charset 属性的浏览器有 IE、Firefox、Safari、Opera 和 Chrome。支持document.defaultCharset 属性的浏览器有 IE、Safari 和 Chrome。 11.3.5 自定义数据属性HTML5规定可以为元素添加非标准的属性，但要添加前缀 data- ，目的是为元素提供与渲染无关的信息，或者提供语义信息。这些属性可以任意添加、随便命名，只要以 data- 开头即可。 1&lt;div id=\"myDiv\" data-appId=\"12345\" data-myname=\"Nicholas\"&gt;&lt;/div&gt; 添加了自定义属性之后，可以通过元素的 dataset 属性来访问自定义属性的值。 dataset 属性的值是 DOMStringMap 的一个实例，也就是一个名值对儿的映射。在这个映射中，每个 data-name 形式的属性都会有一个对应的属性，只不过属性名没有 data- 前缀（比如，自定义属性是 data-myname ，那映射中对应的属性就是 myname ）。 123456789101112131415//本例中使用的方法仅用于演示var div = document.getElementById(\"myDiv\");//取得自定义属性的值var appId = div.dataset.appId;var myName = div.dataset.myname;//设置值div.dataset.appId = 23456;div.dataset.myname = \"Michael\";//有没有\"myname\"值呢？if (div.dataset.myname)&#123; alert(\"Hello, \" + div.dataset.myname);&#125; 如果需要给元素添加一些不可见的数据以便进行其他处理，那就要用到自定义数据属性。在跟踪链接或混搭应用中，通过自定义数据属性能方便地知道点击来自页面中的哪个部分。在编写本书时，支持自定义数据属性的浏览器有 Firefox 6+和 Chrome。 11.3.6 插入标记","tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://y695287173.github.io/tags/javaScript/"}]},{"title":"css下让input按钮指上变小手","date":"2017-02-13T14:36:56.000Z","path":"2017/02/13/pointer/","text":"好久没写总结了啊，公司忙成狗，啊啊啊啊啊~ cursor:pointer;","tags":[{"name":"css","slug":"css","permalink":"https://y695287173.github.io/tags/css/"}]},{"title":"CSS去除内联元素之间的空格","date":"2017-01-04T05:18:58.000Z","path":"2017/01/04/inline-space/","text":"当内联元素不放置于同一行时，因为浏览器将回车视为一个空格，因此会产生间距问题，如下所示 解决方法： 写在同一行中 margin-right设为负值 设置父元素（如body{font-size:0}），然后再设置内联元素字体大小 设置浮动，float:left","tags":[{"name":"css","slug":"css","permalink":"https://y695287173.github.io/tags/css/"}]},{"title":"markdown 入门语法总结","date":"2017-01-03T15:38:04.000Z","path":"2017/01/03/markdown-guide/","text":"Markdown 是一种轻量级的「标记语言」，它的优点很多，目前深受写作爱好者喜爱。对于HTML语言而言，Markdown简单的多，它能写出结构和排版友好的文档，而且学习成本并不高，主要使用的标记也只有十几个。熟悉Markdown的语法后，会感受到它的方便和优雅。以下总结了常用的几个命令。 标题将一段文字定义为标题，只需要在它前面加入1~6个# # 标题1 ## 标题2 ### 标题3 效果： 标题1标题2标题3斜体与粗体Markdown 使用星号和底线来标记需要强调的区段。 我来自*北邮* 我是个_毕业生_ 我是**94**年出生的 我在__华为__工作 效果： 我来自北邮 我是个毕业生 我是94年出生的 我在华为工作 列表在html中列表分为有序列表和无序列表，Markdown中亦然。无序列表的显示方法是在文字前加入-或者*，而有序列表直接宰文字前加入1. 2. 3.即可 无序列表 * 1 * 2 * 3 效果： 1 2 3 有序列表 1. 1 2. 2 3. 3 效果： 1 2 3 引用如果你需要引用一小段别处的句子，那么就要用引用的格式。 只需要在文本前加入 &gt; 这种尖括号（大于号）即可 &gt;例如这样 例如这样 图片和链接图片和链接的语法很像，只相差一个！图片：![altname](url){ImgCap}{/ImgCap}链接：[altname](url) 参考格式为：图片：![altname][referName]链接：[altname][referName][referName]: /img/pic.jpg 此处URL可以为相对路径，也可以放到图床后再填写地址，推荐七牛图床 ![luffy](/img/luffy.jpg) [baidu](www.baidu.com) baidu 表格表格比较麻烦，基本感觉是在画。。。 |tables|name|age| |------|----|---| |row 1 |jack| 20| |row 2 |allen| 21| tables name age row 1 jack 20 row 2 allen 21 代码框如果你需要保持代码格式，在行内只需要用` 包裹起来var test = funciton(){} 而如果你有多行代码需要输出，则只需要在他们行前输入四个空格或者一个tab即可 var test = function(){ alert(&quot;hi&quot;) } 代码高亮如果你需要代码高亮，则需要用如下格式来书写你的代码 123var test = function()&#123; alert(\"hi\")&#125; 分割线分割线的语法只需要三个 * 号，如下","tags":[{"name":"markdown","slug":"markdown","permalink":"https://y695287173.github.io/tags/markdown/"}]},{"title":"markdown语言实现段首空格的显示","date":"2017-01-03T15:19:55.000Z","path":"2017/01/03/markdown-indent/","text":"原则上 markdown语言并不负责实现段首缩进，我们也推荐用CSS完成 p{ text-indent:2em; } 特殊情况下，有如下方式可以实现 手动输入空格，&amp;nbsp;，不推荐，效果如下：&nbsp;&nbsp;缩进后的文字 推荐第二种圆角空格，切换到全角模式下（一般的中文输入法都是按 shift + space）输入两个空格就行了。这个相对 &amp;nbsp; 来说稍微干净一点（markdown文档的结构直观），而且宽度是整整两个汉字，很整齐。 缩进后的文字","tags":[{"name":"markdown","slug":"markdown","permalink":"https://y695287173.github.io/tags/markdown/"}]},{"title":"git常用命令--git clean","date":"2017-01-03T15:06:22.000Z","path":"2017/01/03/git-clean/","text":"项目中的文件可以分成两种状态：tracked, untracked git clean 用于删除一些没有add进来的untracked文件 git clean -n --显示要删除的文件和目录 git clean -f --删除文件 git clean -df --删除文件和目录","tags":[{"name":"git","slug":"git","permalink":"https://y695287173.github.io/tags/git/"}]},{"title":"best gift","date":"2017-01-03T14:58:20.000Z","path":"2017/01/03/best-gift/","text":"朝思墓想的大黄靴，一直都舍不得买，在2017年的第一天，妹子强行给买了 youhohoho~~ 我老婆还是好啊 恩，抓紧挣钱才是正道，干巴爹~","tags":[{"name":"生活","slug":"生活","permalink":"https://y695287173.github.io/tags/生活/"}]},{"title":"git本地创建远端分支","date":"2017-01-03T05:02:49.000Z","path":"2017/01/03/git-branch/","text":"在公司解决问题时，需要创建远端分支，但是每次都要在内源网站上（类似github）点击创建分支，然后再git fetch，git checkout。因为公司代码太多，网站很卡，很容易让人焦虑。然后就在网上找了找本地创建远端分支的技巧，比较简单，代码如下。 创建本地分支 --切到master分支 $git checkout master --创建本地分支 $git branch develop 创建远端分支 $git push origin develop","tags":[{"name":"git","slug":"git","permalink":"https://y695287173.github.io/tags/git/"}]},{"title":"html代码固定，实现文字不居中，图片居中","date":"2017-01-02T07:24:29.000Z","path":"2017/01/02/css-img-center/","text":"css小技巧笔记，html代码固定，实现文字不居中，图片居中 html代码 &lt;div class=&quot;article&quot;&gt; &lt;p&gt;文字不要居中，下面图片要居中&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/tiancai.jpg&quot;&gt;&lt;/p&gt; &lt;/div&gt; css代码 img为内联元素，因此需要改变display方式为bolck.article&gt;p&gt;img{ display:block; margin:0 auto; } 效果 文字不要居中，下面图片要居中","tags":[{"name":"css","slug":"css","permalink":"https://y695287173.github.io/tags/css/"}]},{"title":"2017 第一次写博客","date":"2017-01-02T06:05:53.000Z","path":"2017/01/02/2016-1-2/","text":"2016就这样过去了，这已经是我来到这个世界的第22个年头 现在竟然也已经到了地铁上让个座都要被喊谢谢叔叔的年纪，小时候也常常期盼着长大之后为所欲为 现在想想。。。哈哈 一切都没什么波澜 2016就这么毕业了，工作了，女朋友也好的很 但是刚毕业了半年再听一听郝云的“活着”,就开始共鸣了 也不知道是自己成长的太快了，还是变得矫情了 慌慌张张 匆匆忙忙 为何生活总是这样难道说 我的理想就是这样渡过一生的时光不卑不亢 不慌不忙也许生活应该这样难道说 60岁后再去寻找搜索我想要的自由 有时跟人谈心，我说我很迷茫，看不见自己的未来是什么样的 他们总会说其实大家都是这样的，工作嘛 可是我真的不想这样度过一辈子，我怕我会后悔 总之，不断学习总是没有坏处的 我就付出比别人多一倍的努力又能如何？","tags":[{"name":"生活","slug":"生活","permalink":"https://y695287173.github.io/tags/生活/"}]}]