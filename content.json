[{"title":"前端基础回顾--position","date":"2018-08-09T15:23:45.000Z","path":"2018/08/09/font-position/","text":"前端定位中，允许从正常文档流中取出元素，按照一定的规则放置，以下介绍前端position的四种值和如何使用他们。 参考：https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/%E5%AE%9A%E4%BD%8D z-index 各种情况http://www.cnblogs.com/chaixiaozhi/p/8481253.html calc() = calc(四则运算) 垂直居中：http://www.cnblogs.com/chaixiaozhi/p/8490725.html","tags":[{"name":"前端","slug":"前端","permalink":"https://y695287173.github.io/tags/前端/"}]},{"title":"响应式设计，让div的宽和高及背景等比例放大缩小","date":"2018-06-20T14:35:00.000Z","path":"2018/06/20/response-web-design/","text":"在有些常见需求中，如首页的banner，我们不能指定它的宽和高，单又需要和背景图片进行等比例地调整，且在页面窗口变化的时候仍然保持这个布局。所以我们需要以下两个方法。 参考：https://www.cnblogs.com/GinJiong/articles/5426334.html","tags":[{"name":"css","slug":"css","permalink":"https://y695287173.github.io/tags/css/"},{"name":"前端","slug":"前端","permalink":"https://y695287173.github.io/tags/前端/"}]},{"title":"CountDownLatch在多线程中的作用及用法","date":"2018-03-05T11:08:44.000Z","path":"2018/03/05/java-CountDownLatch/","text":"CountDownLatch的作用用一句话来概括的话，它可以等待你想要的线程正常处理完成后再去处理其他和这些线程时序相关的代码。 使用场景 当你有两个任务在同时进行，而你需要在两个任务都完成时提示用户已完成任务，通常我们可以是join来进行等待。如下 01public class JoinCountDownLatchTest { public static void main(String[] args) throws InterruptedException { Thread task1 = new Thread(new Runnable() { @Override public void run() { System.out.println(“task1 finish”); } }); Thread task2 = new Thread(new Runnable() { @Override public void run() { System.out.println(&quot;task2 finish&quot;); } }); task1.start(); task2.start(); task1.join(); task2.join(); System.out.println(&quot;all task finish&quot;); }} join()用于让当前线程等待指导join线程执行结束，实现原理就是不停地检查join线程是否存活，如果线程存活则让当前线程等待，线程结束后，会调用notify和notifyAll方法唤醒调用线程，代码如下： while (isAlive()) { wait(0);} JDK1.5之后提供了CountDownLatch类，它除了join的功能外，还能提供一些额外的功能 public class CountDownLatchTest { static CountDownLatch c = new CountDownLatch(2); public static void main(String[] args) throws InterruptedException { Thread task1 = new Thread(new Runnable() { @Override public void run() { c.countDown(); System.out.println(&quot;task1 finish&quot;); } }); Thread task2 = new Thread(new Runnable() { @Override public void run() { c.countDown(); System.out.println(&quot;task2 finish&quot;); } }); task1.start(); task2.start(); c.await(); System.out.println(&quot;3&quot;); } } CountDownLatch的构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完成，这里就传入N。 当我们调用一次CountDownLatch的countDown方法时，N就会减1，CountDownLatch的await会阻塞当前线程，直到N变成零。由于countDown方法可以用在任何地方，所以这里说的N个点，可以是N个线程，也可以是1个线程里的N个执行步骤。用在多个线程时，你只需要把这个CountDownLatch的引用传递到线程里。 其他方法如果有某个解析sheet的线程处理的比较慢，我们不可能让主线程一直等待，所以我们可以使用另外一个带指定时间的await方法，await(long time, TimeUnit unit): 这个方法等待特定时间后，就会不再阻塞当前线程。join也有类似的方法。 注意：在需要通过回调函数来执行countDown时注意，如果awit方法在主线程调用，那么会阻塞回调函数的执行，从而导致死锁。计数器必须大于等于0，只是等于0时候，计数器就是零，调用await方法时不会阻塞当前线程。CountDownLatch不可能重新初始化或者修改CountDownLatch对象的内部计数器的值。一个线程调用countDown方法 happen-before 另外一个线程调用await方法。","tags":[{"name":"android","slug":"android","permalink":"https://y695287173.github.io/tags/android/"},{"name":"java","slug":"java","permalink":"https://y695287173.github.io/tags/java/"}]},{"title":"java 泛型学习总结","date":"2018-01-18T09:35:00.000Z","path":"2018/01/18/java-2018-1-18/","text":"在java泛型出现以前，程序员们普遍杂乱地使用Object变量，然后进行强制类型转换，泛型的出现带来了更好的安全性和可读性。泛型对于结合类尤其游泳，就比如我们经常使用的ArrayList。 泛型定义public class Pair{ private T first; private T second; public Pair() { first = null; second = null; } public Pair(T first, T second) { first = first; second = second; } public T getFirst() { return first; } public T getSecond() { return second; } public T setFirst(T newValue) { first = newValue; } public T setSecond(T newValue) { second = newValue; }} T:表示任意类型 实例化泛型类型：Pair 构造函数：Pair()Pair(String,String) 返回泛型方法：public static Pair minmax(String[] a){ … retrun Pair&lt;&gt;(min, max);} 泛型方法class ArrayAlg{ public static T getMiddle(T…a) { return a[a.length/2]; }} 泛型方法可以放在普通类中，也可以放在泛型类中。 调用： String middle = ArrayAlg.getMiddle(“john”,”Q”,”public”); 当编译器有足够信息能推断出T的类型时，上述调用也可以省略为： String middle = ArrayAlg.getMiddle(“john”,”Q”,”public”); 大多数情况下这样调用是没有问题的，但是也有例外 double middle = ArrayAlg.getMiddle(3.14，1729，0); 编译器在推断时发现前三个参数类型为Double和两个Integer，然后寻找这三个参数的共同类型，发现有两个父类型：Number和Comparable接口，这种情况下，可以把三个参数都写为double格式来避免。 类型变量的限定public static Pair minmax(T[] a){ if (a == null || a.length == 0) return null; T min = a[0]; T max = a[0]; for(int i=1;i&lt;a.length;i++) { if(min.compareTo(a[i]) &gt; 0) min = a[i]; if(min.compareTo(a[i]) &lt; 0) max = a[i]; } return new Pair&lt;&gt;(min,max);} 如上述代码，如果你需要的泛型接口必须拥有compareTo方法，那么就需要加上extends Comparable限定。 泛型代码和虚拟机虚拟机中没有泛型，只有普通的类和方法所有的类型参数都用他们的限定类型替换桥方法被合成来保持多态为保持类型安全性，必要时插入强制类型转换 因此在虚拟机处理时，会擦除类型变量，上述Pair类型会被擦除为： public class Pair{ private Object first; private Object second; public Pair() { first = null; second = null; } public Pair(Object first, Object second) { first = first; second = second; } public Object getFirst() { return first; } public Object getSecond() { return second; } public Object setFirst(Object newValue) { first = newValue; } public Object setSecond(Object newValue) { second = newValue; }} 因为T没有限定，所以直接被擦除为Object，如果有限定的类型话就用第一个限定类型来替换，如 public class Interval implements Serializable{ private T lower； private T upper； … public Interval(T first,T second){…}} 擦除后会变为： public class Interval implements Serializable{ private Comparable lower； private Comparable upper； … public Interval(Comparable first,Comparable second){…}} #翻译泛型表达式 当程序调用泛型方法时，如果擦除返回类型，编译器插入强制类型转换，如下语句 Pair buddies = …;Employee buddy = buddies.getFirst(); getFirst被擦除后将返回Object类型，编译器自动插入Employee的强制类型转换，也就是说，编译器会把这个方法调用翻译为两条虚拟机指令 对原始方法Pair.getFirst的调用将返回的Object类型强制转换为Employee类型。 #翻译泛型方法 类型擦除也会出现在泛型方法中，如 public static T min(T[] a) 擦除类型后，只剩下一个方法 public static Comparable min (Comparable[] a) 这样带来了两个复杂问题，如下示例 class DateInterval extends Pair{ public void setSecond(Date second) { if(second.compareTo(getFirst() &gt;= 0)) super.setSecond(second); }} 一个日期区间DateInterval是一对Date对象，而且限定second的值不能小于第一个值，这个类擦除类型后变为 class DateInterval extends Pair //after erasure{ public void setSecond(Date second) { if(second.compareTo(getFirst() &gt;= 0)) super.setSecond(second); }} 令人奇怪的是，存在另一个从Pair继承而来的setSecond方法，即 public void setSecond(Object second) 从重载的角度看，这显然是另一个方法，因为参数不同，但这样会带来一些问题。考虑下列语句序列： DateInterval interval = new DateInterval(…);Pair pair = interval;pair.setSecond(aDate); 从多台的动态绑定考虑，我们肯定希望setSecond调用的是子类DateInterval.setSecond,问题在于类型擦除与多态放生了冲突，虚拟机中不存在泛型类型，因此会直接调用Pair.setSecond(Object …)。 要解决这个问题,就需要编译器在DateInterval类中生成一个桥方法(编译器自动生成)public void setSecond(Object second) { setSecond((Date) second)} https://www.cnblogs.com/xxzhuang/p/5968331.html 约束与局限性不能用基本类型实例化类型参数其本职是因为在类型擦除后，无法用Object来存储基本类型 运行时类型查询只适用于原始类型 if(a instanceof Pair) //ERR实际上仅仅测试a是否是任意类型的一个Pair 或强制类型转换： Pair p = (Pair)a //WARNING–can only test that a is a Pair以上都会触发编译告警同理getClass方法总是会返回原始类型，例如 Pair stringPair = …;Pair employeePair = …;if (stringPair.getClass() == employeePair.getClass()) //they are equal比较结果都是true，因为都返回Pair.class","tags":[{"name":"java","slug":"java","permalink":"https://y695287173.github.io/tags/java/"}]},{"title":"在其他地方修改你的hexo博客","date":"2018-01-18T09:01:04.000Z","path":"2018/01/18/2018-1-18-upload hexo source code/","text":"好久没写博客了，记录下hexo迁移到公司云上吧，如果你是个hexo和git方面的菜鸟想在其他地方使用你的hexo博客来做笔记的话，可以看一下。 最近换了部门，从路由器来到了终端，工作内容有很大改变，想在晚上工作之余总结下学习内容，然后就想起了到路由器就没写的博客。。。。（啊，路由器真的是太坑了，忙成狗~） 然后理所当然地打开了github，把自己用hexo搭的blog clone了下来，然后发现为什么不识别hexo命令，我一度以为是公司内网问题导致npm包下的不全。最后突然想到，hexo deploy上去的是静态页面啊。。。 所以你也遇到我这样的问题话，下面的内容应该对你有用，我们要做的无非就是把hexo的源码和我们的blog内容也上传到github上去，其实我们观察下hexo的目录也可以发现根目录是有一个.gitgnore的，目的就是为了在你上传源码内容时避免把中间生成的静态文件缓存也上传上去。你可能想到，那在github上新建个库不行好了，这样是能解决问题，但是感觉有点冗余。所以用分支就更加地简洁和方便。 创建一个hexo分支，作为我们的源码分支，然后修改_config.yml中的deploy参数，分支应为master。 然后每次就只需要deploy后，把修改后的代码 git push origin hexo上就可以了。 对hexo+github感兴趣的话可以参考下下面的文档，比较简单，就不再赘述了。 hexo官方文档：https://hexo.io/zh-cn/docs/troubleshooting.html","tags":[{"name":"hexo","slug":"hexo","permalink":"https://y695287173.github.io/tags/hexo/"}]},{"title":"清除浮动的几种方法","date":"2017-02-27T14:42:39.000Z","path":"2017/02/27/float-clear/","text":"在CSS布局中，浮动是一个常用的属性，但在子元素设置float属性时height超过父元素，在父元素未设置高度或高度小于子元素时，会出现子元素溢出父元素，从而使父元素高度出现塌陷的情况。而为了防止子元素溢出到父元素包围以外的css处理，就被称为清除浮动 此处引用W3C中清除浮动的例子：http://www.w3school.com.cn/css/css_positioning_floating.asp.news { background-color: gray; border: solid 1px black; } .news img { float: left; } .news p { float: right; } &lt;div class=&quot;news&quot;&gt; &lt;img src=&quot;news-pic.jpg&quot; /&gt; &lt;p&gt;some text&lt;/p&gt; &lt;/div&gt; 主要几种常用清除浮动的方法：方法1：使用css的:after伪元素进行清除浮动.news { background-color: gray; border: solid 1px black; } .news img { float: left; } .news p { float: right; } .clearfix:after{ content: &quot;&quot;; display: block; height: 0; clear: both; visibility: hidden; } .clearfix { /* 触发 hasLayout */ zoom: 1; } &lt;div class=&quot;news clearfix&quot;&gt; &lt;img src=&quot;news-pic.jpg&quot; /&gt; &lt;p&gt;some text&lt;/p&gt; &lt;/div&gt; 此方法的原理为在要清除浮动的父元素最后添加一个带有clear：both属性，且不可见的元素，以此元素来清除浮动。与直接宰父元素最后添加一个带有clear：both的元素原理一直，但是使用：after属性不会因为添加一个无意义的元素而破坏html文档的结构。而zoom：1，是为了触发IE的hasLayout来清除浮动。 方法2：使用CSS的overflow属性overflow:auto; 或 overflow：hidden； 另外同理需要加上zoom：1的IE HACK来兼容IE .news { background-color: gray; border: solid 1px black; overflow: auto; *zoom: 1; } .news img { float: left; } .news p { float: right; } &lt;div class=&quot;news&quot;&gt; &lt;img src=&quot;news-pic.jpg&quot; /&gt; &lt;p&gt;some text&lt;/p&gt; &lt;/div&gt; 此处需要解释一下，这种清除浮动的方式是和上面第一种方式有着不同的原理。第一种方式是利用了父元素内最后一个元素或伪元素具有的clear属性来进行清除浮动的，而此方法是触发了BFC来清除浮动的。即Block formatting contexts （块级格式化上下文），简称 BFC。 BFC 是页面中独立的一个容器，容器内的子元素不会对外部产生影响。 BFC具有如下特性： BFC会阻止内部子元素在垂直方向的外边距重叠（margin），但BFC之间和同一个BFC内的外边距重叠问题仍然存在。 BFC可以包裹住浮动元素 BFC不会重叠浮动元素 因此利用BFC可以包裹浮动元素的特性来清除浮动 方法3：浮动元素的外部元素也设置为浮动元素这种方法因为会影响布局，所以一般也使用不上。主要还是推荐上述两种方法。 具体想深入了解清除浮动的方法和其中的原理，可以参考如下链接： 那些年我们一起清除过的浮动：http://www.iyunlu.com/view/css-xhtml/55.html","tags":[{"name":"css","slug":"css","permalink":"https://y695287173.github.io/tags/css/"}]},{"title":"font 属性简写","date":"2017-02-15T16:06:07.000Z","path":"2017/02/16/font-order/","text":"css 中font的属性可以通过合并成为一个font属性，这样写起来方便，也简化了代码。 font属性 font-family（字体族）: “Arial”、“Times New Roman”、“宋体”、“黑体”等;font-style（字体样式）: normal（正常）、italic（斜体）或oblique（倾斜）;font-variant (字体变化): normal（正常）或small-caps（小体大写字母）;font-weight (字体浓淡): 是normal（正常）或bold（加粗）。有些浏览器甚至支持采用100到900之间的数字（以百为单位）;font-size（字体大小）: 可通过多种不同单位（比如像素或百分比等）来设置, 如：12xp，12pt，120%，1em 简写顺序如下： 顺序：font-style | font-variant | font-weight | font-size | line-height | font-family 举例12345678.font&#123; font-style:italic; font-variant:small-caps; font-weight:bold; font-size:12px; line-height:1.5em; font-family:arial,verdana;&#125; 简写后：1.font&#123;font:italic small-caps bold 12px/1.5em arial,verdana;&#125; 注意 简写时，font-size和line-height只能通过斜杠/组成一个值，不能分开写。 顺序不能改变.这种简写方法只有在同时指定font-size和font-family属性时才起作用。而且，如果你没有设定font-weight, font-style, 以及 font-varient ，他们会使用缺省值","tags":[{"name":"css","slug":"css","permalink":"https://y695287173.github.io/tags/css/"}]},{"title":"《javaScript高级程序设计》第11章 DOM拓展总结","date":"2017-02-14T05:38:04.000Z","path":"2017/02/14/javascriptnote11/","text":"摘录总结自《javaScript高级程序设计》 对 DOM 的两个主要的扩展是 Selectors API（选择符 API）和 HTML5。这两个扩展都源自开发社区，而将某些常见做法及 API 标准化一直是众望所归。此外，还有一个不那么引人瞩目的 Element Traversal（元素遍历）规范，为 DOM 添加了一些属性。虽然前述两个主要规范（特别是 HTML5）已经涵盖了大量的 DOM 扩展，但专有扩展依然存在。本章也会介绍专有的 DOM 扩展。 11.1 选择符 API众多 JavaScript 库中最常用的一项功能，就是根据 CSS 选择符选择与某个模式匹配的 DOM 元素。实际上，jQuery（www.jquery.com）的核心就是通过 CSS 选择符查询 DOM 文档取得元素的引用，从而抛开了 getElementById() 和 getElementsByTagName() 。 Selectors API Level 1的核心是两个方法： querySelector() 和 querySelectorAll() 。在兼容的浏览器中，可以通过 Document 及 Element 类型的实例调用它们。目前已完全支持 Selectors API Level 1的浏览器有 IE 8+、Firefox 3.5+、Safari 3.1+、Chrome和 Opera 10+。 11.1.1 querySelector() 方法querySelector() 方法接收一个 CSS 选择符，返回与该模式匹配的第一个元素，如果没有找到匹配的元素，返回 null 。请看下面的例子。 1234567891011//取得 body 元素var body = document.querySelector(\"body\");//取得 ID 为\"myDiv\"的元素var myDiv = document.querySelector(\"#myDiv\");//取得类为\"selected\"的第一个元素var selected = document.querySelector(\".selected\");//取得类为\"button\"的第一个图像元素var img = document.body.querySelector(\"img.button\"); 如果传入了不被支持的选择符， querySelector()会抛出错误。 11.1.1 querySelectorAll() 方法与querySelector()基本相同，差异为返回全部元素，如下例子： 123456789101112131415//取得某&lt;div&gt;中的所有&lt;em&gt;元素（类似于 getElementsByTagName(\"em\")）var ems = document.getElementById(\"myDiv\").querySelectorAll(\"em\");//取得类为\"selected\"的所有元素var selecteds = document.querySelectorAll(\".selected\");//取得所有&lt;p&gt;元素中的所有&lt;strong&gt;元素var strongs = document.querySelectorAll(\"p strong\");要取得返回的 NodeList 中的每一个元素，可以使用 item() 方法，也可以使用方括号语法，比如：var i, len, strong;for (i=0, len=strongs.length; i &lt; len; i++)&#123; strong = strongs[i]; //或者 strongs.item(i) strong.className = \"important\";&#125; 11.1.3 matchesSelector() 方法Selectors API Level 2 规范为 Element 类型新增了一个方法 matchesSelector() 。这个方法接收一个参数，即 CSS 选择符，如果调用元素与该选择符匹配，返回 true ；否则，返回 false 。看例子。 截至 2011 年年中，还没有浏览器支持 matchesSelector() 方法；不过，也有一些实验性的实现。IE 9+通过 msMatchesSelector() 支持该方法，Firefox 3.6+通过 mozMatchesSelector() 支持该方法，Safari 5+和 Chrome 通过 webkitMatchesSelector() 支持该方法。因此，如果你想使用这个方法，最好是编写一个包装函数。 12345678910111213141516function matchesSelector(element, selector)&#123; if (element.matchesSelector)&#123; return element.matchesSelector(selector); &#125; else if (element.msMatchesSelector)&#123; return element.msMatchesSelector(selector); &#125; else if (element.mozMatchesSelector)&#123; return element.mozMatchesSelector(selector); &#125; else if (element.webkitMatchesSelector)&#123; return element.webkitMatchesSelector(selector); &#125; else &#123; throw new Error(\"Not supported.\"); &#125;&#125;if (matchesSelector(document.body, \"body.page1\"))&#123; //执行操作&#125; 11.2 元素遍历对于元素间的空格，IE9及之前版本不会返回文本节点，而其他所有浏览器都会返回文本节点。这样，就导致了在使用 childNodes 和 firstChild 等属性时的行为不一致。为了弥补这一差异，而同时又保持 DOM规范不变，Element Traversal规范（www.w3.org/TR/ElementTraversal/）新定义了一组属性。Element Traversal API 为 DOM 元素添加了以下 5 个属性。 childElementCount ：返回子元素（不包括文本节点和注释）的个数。firstElementChild ：指向第一个子元素； firstChild 的元素版。lastElementChild ：指向最后一个子元素； lastChild 的元素版。previousElementSibling ：指向前一个同辈元素； previousSibling 的元素版。nextElementSibling ：指向后一个同辈元素； nextSibling 的元素版。 如下： 1234567891011121314151617var i, len,child = element.firstChild;while(child != element.lastChild)&#123; if (child.nodeType == 1)&#123; //检查是不是元素 processChild(child); &#125; child = child.nextSibling;&#125;而使用 Element Traversal 新增的元素，代码会更简洁。var i, len,child = element.firstElementChild;while(child != element.lastElementChild)&#123; processChild(child); //已知其是元素 child = child.nextElementSibling;&#125; 支持 Element Traversal 规范的浏览器有 IE 9+、Firefox 3.5+、Safari 4+、Chrome 和 Opera 10+。 11.3 HTML5为了让开发人员适应并增加对 class 属性的新认识，HTML5 新增了很多 API，致力于简化 CSS 类的用法。 1. getElementsByClassName() 方法这个方法最早出现在 JavaScript 库中，是通过既有的 DOM 功能实现的，而原生的实现具有极大的性能优势。 12345/取得所有类中包含\"username\"和\"current\"的元素，类名的先后顺序无所谓var allCurrentUsernames = document.getElementsByClassName(\"username current\");//取得 ID 为\"myDiv\"的元素中带有类名\"selected\"的所有元素var selected = document.getElementById(\"myDiv\").getElementsByClassName(\"selected\"); 使用这个方法可以更方便地为带有某些类的元素添加事件处理程序，从而不必再局限于使用 ID或标签名。不过别忘了，因为返回的对象是 NodeList ，所以使用这个方法与使用 getElementsByTagName()以及其他返回 NodeList 的 DOM 方法都具有同样的性能问题。支持 getElementsByClassName() 方法的浏览器有 IE 9+、Firefox 3+、Safari 3.1+、Chrome 和Opera 9.5+。 2. classList 属性在HTML5之前，我们要改变元素的class属性时，需要做如下操作： 1&lt;div class=\"bd user disabled\"&gt;...&lt;/div&gt; 这个 元素一共有三个类名。要从中删除一个类名，需要把这三个类名拆开，删除不想要的那个，然后再把其他类名拼成一个新字符串。请看下面的例子。 123456789101112131415161718192021//删除\"user\"类//首先，取得类名字符串并拆分成数组var classNames = div.className.split(/\\s+/);//找到要删的类名var pos = -1, i, len;for (i=0, len=classNames.length; i &lt; len; i++)&#123; if (classNames[i] == \"user\")&#123; pos = i; break; &#125;&#125;//删除类名classNames.splice(i,1);//把剩下的类名拼成字符串并重新设置div.className = classNames.join(\" \"); HTML5 新增了一种操作类名的方式，可以让操作更简单也更安全，那就是为所有元素添加classList 属性。这个 classList 属性是新集合类型 DOMTokenList 的实例。 add(value) ：将给定的字符串值添加到列表中。如果值已经存在，就不添加了。contains(value) ：表示列表中是否存在给定的值，如果存在则返回 true ，否则返回 false 。remove(value) ：从列表中删除给定的字符串。toggle(value) ：如果列表中已经存在给定的值，删除它；如果列表中没有给定的值，添加它。 这样，前面那么多行代码用下面这一行代码就可以代替了： 1div.classList.remove(\"user\"); 以上代码能够确保其他类名不受此次修改的影响。其他方法也能极大地减少类似基本操作的复杂性，如下面的例子所示。 123456789101112131415161718//删除\"disabled\"类div.classList.remove(\"disabled\");//添加\"current\"类div.classList.add(\"current\");//切换\"user\"类div.classList.toggle(\"user\");//确定元素中是否包含既定的类名if (div.classList.contains(\"bd\") &amp;&amp; !div.classList.contains(\"disabled\"))&#123; //执行操作)//迭代类名for (var i=0, len=div.classList.length; i &lt; len; i++)&#123; doSomething(div.classList[i]);&#125; 有了 classList 属性，除非你需要全部删除所有类名，或者完全重写元素的 class 属性，否则也就用不到 className 属性了。 支持 classList 属性的浏览器有 Firefox 3.6+和 Chrome。 11.3.2 焦点管理HTML5 也添加了辅助管理 DOM 焦点的功能。首先就是 document.activeElement 属性，这个属性始终会引用 DOM 中当前获得了焦点的元素。元素获得焦点的方式有页面加载、用户输入（通常是通过按 Tab 键）和在代码中调用 focus() 方法。来看几个例子。 123var button = document.getElementById(\"myButton\");button.focus();alert(document.activeElement === button); //true 默认情况下，文档刚刚加载完成时， document.activeElement 中保存的是 document.body 元素的引用。文档加载期间， document.activeElement 的值为 null 。另外就是新增了 document.hasFocus() 方法，这个方法用于确定文档是否获得了焦点。 12button.focus();alert(document.hasFocus()); //true 实现了这两个属性的浏览器的包括 IE 4+、Firefox 3+、Safari 4+、Chrome 和 Opera 8+。 11.3.3 HTMLDocument 的变化HTML5 扩展了 HTMLDocument ，增加了新的功能。与 HTML5 中新增的其他DOM扩展类似，这些变化同样基于那些已经得到很多浏览器完美支持的专有扩展。所以，尽管这些扩展被写入标准的时间相对不长，但很多浏览器很早就已经支持这些功能了。 1. readyState 属性 loading ，正在加载文档；complete ，已经加载完文档。 在这个属性得到广泛支持之前，要实现这样一个指示器，必须借助 onload 事件处理程序设置一个标签，表明文档已经加载完毕。基本用法： 123if (document.readyState == \"complete\")&#123; //执行操作&#125; 支持 readyState 属性的浏览器有 IE4+、Firefox 3.6+、Safari、Chrome和 Opera 9+。 2. 兼容模式就像下面例子中所展示的那样，在标准模式下， document.compatMode 的值等于 “CSS1Compat” ，而在混杂模式下， document.compatMode 的值等于 “BackCompat” 。 12345if (document.compatMode == \"CSS1Compat\")&#123; alert(\"Standards mode\");&#125; else &#123; alert(\"Quirks mode\");&#125; 后来，陆续实现这个属性的浏览器有 Firefox、Safari 3.1+、Opera 和 Chrome。最终，HTML5 也把这个属性纳入标准，对其实现做出了明确规定。 3. head 属性作为对 document.body 引用文档的 元素的补充，HTML5 新增了 document.head 属性，引用文档的 head 元素。要引用文档的 元素，可以结合使用这个属性和另一种后备方法。 1var head = document.head || document.getElementsByTagName(\"head\")[0]; 如果可用，就使用 document.head ，否则仍然使用 getElementsByTagName() 方法。实现 document.head 属性的浏览器包括 Chrome 和 Safari 5。 11.3.4 字符集属性12alert(document.charset); //\"UTF-16\"document.charset = \"UTF-8\"; 如果文档没有使用默认的字符集，那 charset 和 defaultCharset 属性的值可能会不一样，例如： 123if (document.charset != document.defaultCharset)&#123; alert(\"Custom character set being used.\");&#125; 支持 document.charset 属性的浏览器有 IE、Firefox、Safari、Opera 和 Chrome。支持document.defaultCharset 属性的浏览器有 IE、Safari 和 Chrome。 11.3.5 自定义数据属性HTML5规定可以为元素添加非标准的属性，但要添加前缀 data- ，目的是为元素提供与渲染无关的信息，或者提供语义信息。这些属性可以任意添加、随便命名，只要以 data- 开头即可。 1&lt;div id=\"myDiv\" data-appId=\"12345\" data-myname=\"Nicholas\"&gt;&lt;/div&gt; 添加了自定义属性之后，可以通过元素的 dataset 属性来访问自定义属性的值。 dataset 属性的值是 DOMStringMap 的一个实例，也就是一个名值对儿的映射。在这个映射中，每个 data-name 形式的属性都会有一个对应的属性，只不过属性名没有 data- 前缀（比如，自定义属性是 data-myname ，那映射中对应的属性就是 myname ）。 123456789101112131415//本例中使用的方法仅用于演示var div = document.getElementById(\"myDiv\");//取得自定义属性的值var appId = div.dataset.appId;var myName = div.dataset.myname;//设置值div.dataset.appId = 23456;div.dataset.myname = \"Michael\";//有没有\"myname\"值呢？if (div.dataset.myname)&#123; alert(\"Hello, \" + div.dataset.myname);&#125; 如果需要给元素添加一些不可见的数据以便进行其他处理，那就要用到自定义数据属性。在跟踪链接或混搭应用中，通过自定义数据属性能方便地知道点击来自页面中的哪个部分。在编写本书时，支持自定义数据属性的浏览器有 Firefox 6+和 Chrome。 11.3.6 插入标记","tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://y695287173.github.io/tags/javaScript/"}]},{"title":"css下让input按钮指上变小手","date":"2017-02-13T14:36:56.000Z","path":"2017/02/13/pointer/","text":"好久没写总结了啊，公司忙成狗，啊啊啊啊啊~ cursor:pointer;","tags":[{"name":"css","slug":"css","permalink":"https://y695287173.github.io/tags/css/"}]},{"title":"CSS去除内联元素之间的空格","date":"2017-01-04T05:18:58.000Z","path":"2017/01/04/inline-space/","text":"当内联元素不放置于同一行时，因为浏览器将回车视为一个空格，因此会产生间距问题，如下所示 解决方法： 写在同一行中 margin-right设为负值 设置父元素（如body{font-size:0}），然后再设置内联元素字体大小 设置浮动，float:left","tags":[{"name":"css","slug":"css","permalink":"https://y695287173.github.io/tags/css/"}]},{"title":"markdown 入门语法总结","date":"2017-01-03T15:38:04.000Z","path":"2017/01/03/markdown-guide/","text":"Markdown 是一种轻量级的「标记语言」，它的优点很多，目前深受写作爱好者喜爱。对于HTML语言而言，Markdown简单的多，它能写出结构和排版友好的文档，而且学习成本并不高，主要使用的标记也只有十几个。熟悉Markdown的语法后，会感受到它的方便和优雅。以下总结了常用的几个命令。 标题将一段文字定义为标题，只需要在它前面加入1~6个# # 标题1 ## 标题2 ### 标题3 效果： 标题1标题2标题3斜体与粗体Markdown 使用星号和底线来标记需要强调的区段。 我来自*北邮* 我是个_毕业生_ 我是**94**年出生的 我在__华为__工作 效果： 我来自北邮 我是个毕业生 我是94年出生的 我在华为工作 列表在html中列表分为有序列表和无序列表，Markdown中亦然。无序列表的显示方法是在文字前加入-或者*，而有序列表直接宰文字前加入1. 2. 3.即可 无序列表 * 1 * 2 * 3 效果： 1 2 3 有序列表 1. 1 2. 2 3. 3 效果： 1 2 3 引用如果你需要引用一小段别处的句子，那么就要用引用的格式。 只需要在文本前加入 &gt; 这种尖括号（大于号）即可 &gt;例如这样 例如这样 图片和链接图片和链接的语法很像，只相差一个！图片：![altname](url){ImgCap}{/ImgCap}链接：[altname](url) 参考格式为：图片：![altname][referName]链接：[altname][referName][referName]: /img/pic.jpg 此处URL可以为相对路径，也可以放到图床后再填写地址，推荐七牛图床 ![luffy](/img/luffy.jpg) [baidu](www.baidu.com) baidu 表格表格比较麻烦，基本感觉是在画。。。 |tables|name|age| |------|----|---| |row 1 |jack| 20| |row 2 |allen| 21| tables name age row 1 jack 20 row 2 allen 21 代码框如果你需要保持代码格式，在行内只需要用 包裹起来var test = funciton(){}` 而如果你有多行代码需要输出，则只需要在他们行前输入四个空格或者一个tab即可 var test = function(){ alert(&quot;hi&quot;) } 代码高亮如果你需要代码高亮，则需要用如下格式来书写你的代码 123var test = function()&#123; alert(\"hi\")&#125; 分割线分割线的语法只需要三个 * 号，如下","tags":[{"name":"markdown","slug":"markdown","permalink":"https://y695287173.github.io/tags/markdown/"}]},{"title":"markdown语言实现段首空格的显示","date":"2017-01-03T15:19:55.000Z","path":"2017/01/03/markdown-indent/","text":"原则上 markdown语言并不负责实现段首缩进，我们也推荐用CSS完成 p{ text-indent:2em; } 特殊情况下，有如下方式可以实现 手动输入空格，&amp;nbsp;，不推荐，效果如下：&nbsp;&nbsp;缩进后的文字 推荐第二种圆角空格，切换到全角模式下（一般的中文输入法都是按 shift + space）输入两个空格就行了。这个相对 &amp;nbsp; 来说稍微干净一点（markdown文档的结构直观），而且宽度是整整两个汉字，很整齐。 缩进后的文字","tags":[{"name":"markdown","slug":"markdown","permalink":"https://y695287173.github.io/tags/markdown/"}]},{"title":"git常用命令--git clean","date":"2017-01-03T15:06:22.000Z","path":"2017/01/03/git-clean/","text":"项目中的文件可以分成两种状态：tracked, untracked git clean 用于删除一些没有add进来的untracked文件 git clean -n --显示要删除的文件和目录 git clean -f --删除文件 git clean -df --删除文件和目录","tags":[{"name":"git","slug":"git","permalink":"https://y695287173.github.io/tags/git/"}]},{"title":"best gift","date":"2017-01-03T14:58:20.000Z","path":"2017/01/03/best-gift/","text":"朝思墓想的大黄靴，一直都舍不得买，在2017年的第一天，妹子强行给买了 youhohoho~~ 我老婆还是好啊 恩，抓紧挣钱才是正道，干巴爹~","tags":[{"name":"生活","slug":"生活","permalink":"https://y695287173.github.io/tags/生活/"}]},{"title":"git本地创建远端分支","date":"2017-01-03T05:02:49.000Z","path":"2017/01/03/git-branch/","text":"在公司解决问题时，需要创建远端分支，但是每次都要在内源网站上（类似github）点击创建分支，然后再git fetch，git checkout。因为公司代码太多，网站很卡，很容易让人焦虑。然后就在网上找了找本地创建远端分支的技巧，比较简单，代码如下。 创建本地分支 --切到master分支 $git checkout master --创建本地分支 $git branch develop 创建远端分支 $git push origin develop","tags":[{"name":"git","slug":"git","permalink":"https://y695287173.github.io/tags/git/"}]},{"title":"html代码固定，实现文字不居中，图片居中","date":"2017-01-02T07:24:29.000Z","path":"2017/01/02/css-img-center/","text":"css小技巧笔记，html代码固定，实现文字不居中，图片居中 html代码 &lt;div class=&quot;article&quot;&gt; &lt;p&gt;文字不要居中，下面图片要居中&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/tiancai.jpg&quot;&gt;&lt;/p&gt; &lt;/div&gt; css代码 img为内联元素，因此需要改变display方式为bolck.article&gt;p&gt;img{ display:block; margin:0 auto; } 效果 文字不要居中，下面图片要居中","tags":[{"name":"css","slug":"css","permalink":"https://y695287173.github.io/tags/css/"}]},{"title":"2017 第一次写博客","date":"2017-01-02T06:05:53.000Z","path":"2017/01/02/2016-1-2/","text":"2016就这样过去了，这已经是我来到这个世界的第22个年头 现在竟然也已经到了地铁上让个座都要被喊谢谢叔叔的年纪，小时候也常常期盼着长大之后为所欲为 现在想想。。。哈哈 一切都没什么波澜 2016就这么毕业了，工作了，女朋友也好的很 但是刚毕业了半年再听一听郝云的“活着”,就开始共鸣了 也不知道是自己成长的太快了，还是变得矫情了 慌慌张张 匆匆忙忙 为何生活总是这样难道说 我的理想就是这样渡过一生的时光不卑不亢 不慌不忙也许生活应该这样难道说 60岁后再去寻找搜索我想要的自由 有时跟人谈心，我说我很迷茫，看不见自己的未来是什么样的 他们总会说其实大家都是这样的，工作嘛 可是我真的不想这样度过一辈子，我怕我会后悔 总之，不断学习总是没有坏处的 我就付出比别人多一倍的努力又能如何？","tags":[{"name":"生活","slug":"生活","permalink":"https://y695287173.github.io/tags/生活/"}]}]