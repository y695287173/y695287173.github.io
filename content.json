[{"title":"《javaScript高级程序设计》第11章 DOM拓展总结","date":"2017-02-14T05:38:04.000Z","path":"2017/02/14/javascriptnote11/","text":"对 DOM 的两个主要的扩展是 Selectors API（选择符 API）和 HTML5。这两个扩展都源自开发社区，而将某些常见做法及 API 标准化一直是众望所归。此外，还有一个不那么引人瞩目的 Element Traversal（元素遍历）规范，为 DOM 添加了一些属性。虽然前述两个主要规范（特别是 HTML5）已经涵盖了大量的 DOM 扩展，但专有扩展依然存在。本章也会介绍专有的 DOM 扩展。 11.1 选择符 API众多 JavaScript 库中最常用的一项功能，就是根据 CSS 选择符选择与某个模式匹配的 DOM 元素。实际上，jQuery（www.jquery.com）的核心就是通过 CSS 选择符查询 DOM 文档取得元素的引用，从而抛开了 getElementById() 和 getElementsByTagName() 。 Selectors API Level 1的核心是两个方法： querySelector() 和 querySelectorAll() 。在兼容的浏览器中，可以通过 Document 及 Element 类型的实例调用它们。目前已完全支持 Selectors API Level 1的浏览器有 IE 8+、Firefox 3.5+、Safari 3.1+、Chrome和 Opera 10+。 11.1.1 querySelector() 方法querySelector() 方法接收一个 CSS 选择符，返回与该模式匹配的第一个元素，如果没有找到匹配的元素，返回 null 。请看下面的例子。 12345678//取得 body 元素var body = document.querySelector(\"body\");//取得 ID 为\"myDiv\"的元素var myDiv = document.querySelector(\"#myDiv\");//取得类为\"selected\"的第一个元素var selected = document.querySelector(\".selected\");//取得类为\"button\"的第一个图像元素var img = document.body.querySelector(\"img.button\"); 如果传入了不被支持的选择符， querySelector()会抛出错误。 11.1.1 querySelectorAll() 方法与querySelector()基本相同，差异为返回全部元素，如下例子： 123456789101112//取得某&lt;div&gt;中的所有&lt;em&gt;元素（类似于 getElementsByTagName(\"em\")）var ems = document.getElementById(\"myDiv\").querySelectorAll(\"em\");//取得类为\"selected\"的所有元素var selecteds = document.querySelectorAll(\".selected\");//取得所有&lt;p&gt;元素中的所有&lt;strong&gt;元素var strongs = document.querySelectorAll(\"p strong\");要取得返回的 NodeList 中的每一个元素，可以使用 item() 方法，也可以使用方括号语法，比如：var i, len, strong;for (i=0, len=strongs.length; i &lt; len; i++)&#123;strong = strongs[i]; //或者 strongs.item(i)strong.className = \"important\";&#125; 11.1.3 matchesSelector() 方法Selectors API Level 2 规范为 Element 类型新增了一个方法 matchesSelector() 。这个方法接收一个参数，即 CSS 选择符，如果调用元素与该选择符匹配，返回 true ；否则，返回 false 。看例子。 截至 2011 年年中，还没有浏览器支持 matchesSelector() 方法；不过，也有一些实验性的实现。IE 9+通过 msMatchesSelector() 支持该方法，Firefox 3.6+通过 mozMatchesSelector() 支持该方法，Safari 5+和 Chrome 通过 webkitMatchesSelector() 支持该方法。因此，如果你想使用这个方法，最好是编写一个包装函数。 12345678910111213141516function matchesSelector(element, selector)&#123;if (element.matchesSelector)&#123;return element.matchesSelector(selector);&#125; else if (element.msMatchesSelector)&#123;return element.msMatchesSelector(selector);&#125; else if (element.mozMatchesSelector)&#123;return element.mozMatchesSelector(selector);&#125; else if (element.webkitMatchesSelector)&#123;return element.webkitMatchesSelector(selector);&#125; else &#123;throw new Error(\"Not supported.\");&#125;&#125;if (matchesSelector(document.body, \"body.page1\"))&#123;//执行操作&#125; 11.2 元素遍历对于元素间的空格，IE9及之前版本不会返回文本节点，而其他所有浏览器都会返回文本节点。这样，就导致了在使用 childNodes 和 firstChild 等属性时的行为不一致。为了弥补这一差异，而同时又保持 DOM规范不变，Element Traversal规范（www.w3.org/TR/ElementTraversal/）新定义了一组属性。Element Traversal API 为 DOM 元素添加了以下 5 个属性。 childElementCount ：返回子元素（不包括文本节点和注释）的个数。firstElementChild ：指向第一个子元素； firstChild 的元素版。lastElementChild ：指向最后一个子元素； lastChild 的元素版。previousElementSibling ：指向前一个同辈元素； previousSibling 的元素版。nextElementSibling ：指向后一个同辈元素； nextSibling 的元素版。 如下： 1234567891011121314151617var i,len,child = element.firstChild;while(child != element.lastChild)&#123;if (child.nodeType == 1)&#123; //检查是不是元素processChild(child);&#125;child = child.nextSibling;&#125;而使用 Element Traversal 新增的元素，代码会更简洁。var i,len,child = element.firstElementChild;while(child != element.lastElementChild)&#123;processChild(child); //已知其是元素child = child.nextElementSibling;&#125; 支持 Element Traversal 规范的浏览器有 IE 9+、Firefox 3.5+、Safari 4+、Chrome 和 Opera 10+。 11.3 HTML5为了让开发人员适应并增加对 class 属性的新认识，HTML5 新增了很多 API，致力于简化 CSS 类的用法。 1. getElementsByClassName() 方法这个方法最早出现在 JavaScript 库中，是通过既有的 DOM 功能实现的，而原生的实现具有极大的性能优势。 1234/取得所有类中包含\"username\"和\"current\"的元素，类名的先后顺序无所谓var allCurrentUsernames = document.getElementsByClassName(\"username current\");//取得 ID 为\"myDiv\"的元素中带有类名\"selected\"的所有元素var selected = document.getElementById(\"myDiv\").getElementsByClassName(\"selected\"); 使用这个方法可以更方便地为带有某些类的元素添加事件处理程序，从而不必再局限于使用 ID或标签名。不过别忘了，因为返回的对象是 NodeList ，所以使用这个方法与使用 getElementsByTagName()以及其他返回 NodeList 的 DOM 方法都具有同样的性能问题。支持 getElementsByClassName() 方法的浏览器有 IE 9+、Firefox 3+、Safari 3.1+、Chrome 和Opera 9.5+。 2. classList 属性在HTML5之前，我们要改变元素的class属性时，需要做如下操作： 1&lt;div class=\"bd user disabled\"&gt;...&lt;/div&gt; 这个 元素一共有三个类名。要从中删除一个类名，需要把这三个类名拆开，删除不想要的那个，然后再把其他类名拼成一个新字符串。请看下面的例子。 123456789101112131415161718192021//删除\"user\"类//首先，取得类名字符串并拆分成数组var classNames = div.className.split(/\\s+/);//找到要删的类名var pos = -1, i, len;for (i=0, len=classNames.length; i &lt; len; i++)&#123; if (classNames[i] == \"user\")&#123; pos = i; break; &#125;&#125;//删除类名classNames.splice(i,1);//把剩下的类名拼成字符串并重新设置div.className = classNames.join(\" \"); HTML5 新增了一种操作类名的方式，可以让操作更简单也更安全，那就是为所有元素添加classList 属性。这个 classList 属性是新集合类型 DOMTokenList 的实例。 add(value) ：将给定的字符串值添加到列表中。如果值已经存在，就不添加了。contains(value) ：表示列表中是否存在给定的值，如果存在则返回 true ，否则返回 false 。remove(value) ：从列表中删除给定的字符串。toggle(value) ：如果列表中已经存在给定的值，删除它；如果列表中没有给定的值，添加它。 这样，前面那么多行代码用下面这一行代码就可以代替了： 1div.classList.remove(\"user\"); 以上代码能够确保其他类名不受此次修改的影响。其他方法也能极大地减少类似基本操作的复杂性，如下面的例子所示。 123456789101112131415161718//删除\"disabled\"类div.classList.remove(\"disabled\");//添加\"current\"类div.classList.add(\"current\");//切换\"user\"类div.classList.toggle(\"user\");//确定元素中是否包含既定的类名if (div.classList.contains(\"bd\") &amp;&amp; !div.classList.contains(\"disabled\"))&#123;//执行操作)//迭代类名for (var i=0, len=div.classList.length; i &lt; len; i++)&#123;doSomething(div.classList[i]);&#125; 有了 classList 属性，除非你需要全部删除所有类名，或者完全重写元素的 class 属性，否则也就用不到 className 属性了。 支持 classList 属性的浏览器有 Firefox 3.6+和 Chrome。 11.3.2 焦点管理HTML5 也添加了辅助管理 DOM 焦点的功能。首先就是 document.activeElement 属性，这个属性始终会引用 DOM 中当前获得了焦点的元素。元素获得焦点的方式有页面加载、用户输入（通常是通过按 Tab 键）和在代码中调用 focus() 方法。来看几个例子。 123var button = document.getElementById(\"myButton\");button.focus();alert(document.activeElement === button); //true 默认情况下，文档刚刚加载完成时， document.activeElement 中保存的是 document.body 元素的引用。文档加载期间， document.activeElement 的值为 null 。另外就是新增了 document.hasFocus() 方法，这个方法用于确定文档是否获得了焦点。 12button.focus();alert(document.hasFocus()); //true 实现了这两个属性的浏览器的包括 IE 4+、Firefox 3+、Safari 4+、Chrome 和 Opera 8+。","tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://y695287173.github.io/tags/javaScript/"}]},{"title":"css下让input按钮指上变小手","date":"2017-02-13T14:36:56.000Z","path":"2017/02/13/pointer/","text":"好久没写总结了啊，公司忙成狗，啊啊啊啊啊~ cursor:pointer;","tags":[{"name":"css","slug":"css","permalink":"https://y695287173.github.io/tags/css/"}]},{"title":"CSS去除内联元素之间的空格","date":"2017-01-04T05:18:58.000Z","path":"2017/01/04/inline-space/","text":"当内联元素不放置于同一行时，因为浏览器将回车视为一个空格，因此会产生间距问题，如下所示 解决方法： 写在同一行中 margin-right设为负值 设置父元素（如body{font-size:0}），然后再设置内联元素字体大小 设置浮动，float:left","tags":[{"name":"css","slug":"css","permalink":"https://y695287173.github.io/tags/css/"}]},{"title":"markdown 入门语法总结","date":"2017-01-03T15:38:04.000Z","path":"2017/01/03/markdown-guide/","text":"Markdown 是一种轻量级的「标记语言」，它的优点很多，目前深受写作爱好者喜爱。对于HTML语言而言，Markdown简单的多，它能写出结构和排版友好的文档，而且学习成本并不高，主要使用的标记也只有十几个。熟悉Markdown的语法后，会感受到它的方便和优雅。以下总结了常用的几个命令。 标题将一段文字定义为标题，只需要在它前面加入1~6个# # 标题1 ## 标题2 ### 标题3 效果： 标题1标题2标题3斜体与粗体Markdown 使用星号和底线来标记需要强调的区段。 我来自*北邮* 我是个_毕业生_ 我是**94**年出生的 我在__华为__工作 效果： 我来自北邮 我是个毕业生 我是94年出生的 我在华为工作 列表在html中列表分为有序列表和无序列表，Markdown中亦然。无序列表的显示方法是在文字前加入-或者*，而有序列表直接宰文字前加入1. 2. 3.即可 无序列表 * 1 * 2 * 3 效果： 1 2 3 有序列表 1. 1 2. 2 3. 3 效果： 1 2 3 引用如果你需要引用一小段别处的句子，那么就要用引用的格式。 只需要在文本前加入 &gt; 这种尖括号（大于号）即可 &gt;例如这样 例如这样 图片和链接图片和链接的语法很像，只相差一个！图片：![altname](url){ImgCap}{/ImgCap}链接：[altname](url) 参考格式为：图片：![altname][referName]链接：[altname][referName][referName]: /img/pic.jpg 此处URL可以为相对路径，也可以放到图床后再填写地址，推荐七牛图床 ![luffy](/img/luffy.jpg) [baidu](www.baidu.com) baidu 表格表格比较麻烦，基本感觉是在画。。。 |tables|name|age| |------|----|---| |row 1 |jack| 20| |row 2 |allen| 21| tables name age row 1 jack 20 row 2 allen 21 代码框如果你需要保持代码格式，在行内只需要用` 包裹起来var test = funciton(){} 而如果你有多行代码需要输出，则只需要在他们行前输入四个空格或者一个tab即可 var test = function(){ alert(&quot;hi&quot;) } 代码高亮如果你需要代码高亮，则需要用如下格式来书写你的代码 123var test = function()&#123; alert(\"hi\")&#125; 分割线分割线的语法只需要三个 * 号，如下","tags":[{"name":"markdown","slug":"markdown","permalink":"https://y695287173.github.io/tags/markdown/"}]},{"title":"markdown语言实现段首空格的显示","date":"2017-01-03T15:19:55.000Z","path":"2017/01/03/markdown-indent/","text":"原则上 markdown语言并不负责实现段首缩进，我们也推荐用CSS完成 p{ text-indent:2em; } 特殊情况下，有如下方式可以实现 手动输入空格，&amp;nbsp;，不推荐，效果如下：&nbsp;&nbsp;缩进后的文字 推荐第二种圆角空格，切换到全角模式下（一般的中文输入法都是按 shift + space）输入两个空格就行了。这个相对 &amp;nbsp; 来说稍微干净一点（markdown文档的结构直观），而且宽度是整整两个汉字，很整齐。 缩进后的文字","tags":[{"name":"markdown","slug":"markdown","permalink":"https://y695287173.github.io/tags/markdown/"}]},{"title":"git常用命令--git clean","date":"2017-01-03T15:06:22.000Z","path":"2017/01/03/git-clean/","text":"项目中的文件可以分成两种状态：tracked, untracked git clean 用于删除一些没有add进来的untracked文件 git clean -n --显示要删除的文件和目录 git clean -f --删除文件 git clean -df --删除文件和目录","tags":[{"name":"git","slug":"git","permalink":"https://y695287173.github.io/tags/git/"}]},{"title":"best gift","date":"2017-01-03T14:58:20.000Z","path":"2017/01/03/best-gift/","text":"朝思墓想的大黄靴，一直都舍不得买，在2017年的第一天，妹子强行给买了 youhohoho~~ 我老婆还是好啊 恩，抓紧挣钱才是正道，干巴爹~","tags":[{"name":"生活","slug":"生活","permalink":"https://y695287173.github.io/tags/生活/"}]},{"title":"git本地创建远端分支","date":"2017-01-03T05:02:49.000Z","path":"2017/01/03/git-branch/","text":"在公司解决问题时，需要创建远端分支，但是每次都要在内源网站上（类似github）点击创建分支，然后再git fetch，git checkout。因为公司代码太多，网站很卡，很容易让人焦虑。然后就在网上找了找本地创建远端分支的技巧，比较简单，代码如下。 创建本地分支 --切到master分支 $git checkout master --创建本地分支 $git branch develop 创建远端分支 $git push origin develop","tags":[{"name":"git","slug":"git","permalink":"https://y695287173.github.io/tags/git/"}]},{"title":"html代码固定，实现文字不居中，图片居中","date":"2017-01-02T07:24:29.000Z","path":"2017/01/02/css-img-center/","text":"css小技巧笔记，html代码固定，实现文字不居中，图片居中 html代码 &lt;div class=&quot;article&quot;&gt; &lt;p&gt;文字不要居中，下面图片要居中&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/tiancai.jpg&quot;&gt;&lt;/p&gt; &lt;/div&gt; css代码 img为内联元素，因此需要改变display方式为bolck.article&gt;p&gt;img{ display:block; margin:0 auto; } 效果 文字不要居中，下面图片要居中","tags":[{"name":"css","slug":"css","permalink":"https://y695287173.github.io/tags/css/"}]},{"title":"2017 第一次写博客","date":"2017-01-02T06:05:53.000Z","path":"2017/01/02/2016-1-2/","text":"2016就这样过去了，这已经是我来到这个世界的第22个年头 现在竟然也已经到了地铁上让个座都要被喊谢谢叔叔的年纪，小时候也常常期盼着长大之后为所欲为 现在想想。。。哈哈 一切都没什么波澜 2016就这么毕业了，工作了，女朋友也好的很 但是刚毕业了半年再听一听郝云的“活着”,就开始共鸣了 也不知道是自己成长的太快了，还是变得矫情了 慌慌张张 匆匆忙忙 为何生活总是这样难道说 我的理想就是这样渡过一生的时光不卑不亢 不慌不忙也许生活应该这样难道说 60岁后再去寻找搜索我想要的自由 有时跟人谈心，我说我很迷茫，看不见自己的未来是什么样的 他们总会说其实大家都是这样的，工作嘛 可是我真的不想这样度过一辈子，我怕我会后悔 总之，不断学习总是没有坏处的 我就付出比别人多一倍的努力又能如何？","tags":[{"name":"生活","slug":"生活","permalink":"https://y695287173.github.io/tags/生活/"}]}]